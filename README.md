# rs-lang

English learning app

### Структура проекта: ###

- src
  - components
    - component folder
      - component.tsx
      - component.module.scss
      - types.ts
  - pages
    - main page component folder
      - main.tsx
      - main.module.scss
      - types.ts
    - textbook page component folder
      - texbook.tsx
      - textbook.module.scss
      - types.ts
  - store
    - index.ts
  - variables
    - переменные и константы
  - api
    - файлы, относящиеся к работе с апи
  - helpers
    - различные вспомогательные функции
  - assets
    - images
    - icons
    - fonts
    - sounds
  - styles
    - base.scss - базовые общие стили
    - общие файлы для всего проекта, не генерирующие при сборке самостоятельных стилей (переменные, функции, миксины и т.д.). Все стили пишутся в стилевом файле своего компонента! Благодаря `css-modules` можно не беспокоиться об уникальности имен классов за пределами компонента - т.е., например, в каждом компоненте может быть элемент с классом `wrapper`, в итоговом бандле им будут присвоены разные имена

Если компонент принимает какие-то пропсы, их нужно типизировать. Пропсы - это объект, интерфейс к нему нужно писать в файле types.ts и импортировать в файл самого компонента. Далее тип указывается так:

```
const Component: React.FC<IComponentProps> = () => { ... };
```

Имя компонента обязательно должно начинаться с заглавной буквы, иначе Реакт не поймет, что это компонент.
Если у компонента нет потребности в типизации, то файл types.ts не создается.

### MobX ###

В файле стора создан объект класса Store, импортируется только он, другие экземпляры класса создавать не нужно. При необходимости или для разделения ответственности, можно создать другие классы аналогично существующему. Никакой связи между ними не нужно, они существуют сами по себе. Если в компоненте используется значение из стора, то для того, чтобы значение было реактивным, его нужно обернуть в функцию `observer`. Она импортируется в файл компонента из пакета `'mobx-react-lite'`. В итоге компонент выглядит так:

```
const Component = observer(() => { ... });
```

Внутри класса Store создаются свойства, которые необходимо хранить и методы, управляющие их состоянием. Нежелательно изменение свойства стора за пределами класса (в компоненте). Если это все-таки необходимо, то изменяющую функцию нужно обернуть в функцию `action`. Она импортируется из пакета `'mobx'`:

```
action(() => store.data = anotherData);
```

Также MobX поддерживает computed-значения - значения, вычисляемые на основе хранимых. Например, порядок сортировки. Для создания такого значения нужно написать для него геттер:

```
class Store {
  users: IUsers[] = [];

  constructor() {
    ...

    this.fetchUsers();
  }

  async fetchUsers = () => { ... };

  get ascendingUsers = () => {
    return this.users.sort((a, b) => a.name - b.name);
  }
}
```

Теперь к этому значению можно обращаться из компонента:

```
<div classname={styles.users}>
  {
    store.ascendingUsers.map((item) => <User user={item} key={item.id} />)
  }
</div>
```

Важный момент - при генерации компонентов в цикле для генерируемого компонента необходимо указывать ключ - какое-либо уникальное значение. Это ориентир для реакта, связанный с оптимизацией рендера. Например, при изменении одного значения в массиве, реакт по ключу будет определять, какой именно компонент нужно перерисовать. Не рекомендуется использовать для значения ключа индекс элемента, т.к. он может поменяться. Если нет заведомо уникальных значений (id), то можно использовать комбинацию нескольких. Например, индекс + имя.


### Routing ###

Для доступа на страницу через адресную строку нужно указывать в пути хэш.

```
http://localhost:8080/#/textbook

```
